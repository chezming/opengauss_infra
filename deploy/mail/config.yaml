---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mailman-core-configmap
  namespace: mail
data:
  command.py: |
    # Copyright (C) 1998-2021 by the Free Software Foundation, Inc.
    #
    # This file is part of GNU Mailman.
    #
    # GNU Mailman is free software: you can redistribute it and/or modify it under
    # the terms of the GNU General Public License as published by the Free
    # Software Foundation, either version 3 of the License, or (at your option)
    # any later version.
    #
    # GNU Mailman is distributed in the hope that it will be useful, but WITHOUT
    # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
    # more details.
    #
    # You should have received a copy of the GNU General Public License along with
    # GNU Mailman.  If not, see <https://www.gnu.org/licenses/>.

    """-request robot command runner."""

    # See the delivery diagram in IncomingRunner.py.  This module handles all
    # email destined for mylist-request, -join, and -leave.  It no longer handles
    # bounce messages (i.e. -admin or -bounces), nor does it handle mail to
    # -owner.

    import base64
    import re
    import logging

    from contextlib import suppress
    from email.errors import HeaderParseError
    from email.header import decode_header, make_header
    from email.iterators import typed_subpart_iterator
    from io import StringIO
    from mailman.config import config
    from mailman.core.i18n import _
    from mailman.core.runner import Runner
    from mailman.email.message import UserNotification
    from mailman.interfaces.autorespond import ResponseAction
    from mailman.interfaces.command import ContinueProcessing, IEmailResults
    from mailman.interfaces.languages import ILanguageManager
    from public import public
    from zope.component import getUtility
    from zope.interface import implementer


    NL = '\n'
    log = logging.getLogger('mailman.vette')
    class CommandFinder:
        """Generate commands from the content of a message."""
        def __init__(self, msg, msgdata, results):
            self.command_lines = []
            self.ignored_lines = []
            self.processed_lines = []
            self.send_response = True
            # Depending on where the message was destined to, add some implicit
            # commands.  For example, if this was sent to the -join or -leave
            # addresses, it's the same as if 'join' or 'leave' commands were sent
            # to the -request address.
            is_address_command = False
            subaddress = msgdata.get('subaddress')
            if subaddress == 'join':
                self.command_lines.append('join')
                self.send_response = False
                is_address_command = True
            elif subaddress == 'leave':
                self.command_lines.append('leave')
                is_address_command = True
                self.send_response = False
            elif subaddress == 'confirm':
                mo = re.match(config.mta.verp_confirm_regexp, msg.get('to', ''))
                if mo:
                    self.command_lines.append('confirm ' + mo.group('cookie'))
                    is_address_command = True
                    self.send_response = False
            # Stop processing if the address already contained a valid command
            if is_address_command:
                return
            # Extract the subject header and do RFC 2047 decoding.
            raw_subject = msg.get('subject', '')
            try:
                subject = str(make_header(decode_header(raw_subject)))
                # Mail commands must be ASCII.
                # NOTE(tommylikehu): remove all none ascii characters via encoding with ignore option.
                self.command_lines.append(subject.encode('us-ascii', 'ignore'))
            except (HeaderParseError, UnicodeError, LookupError):
                # The Subject header was unparseable or not ASCII.  If the raw
                # subject is a unicode object, convert it to ASCII ignoring all
                # bogus characters.  Otherwise, there's nothing in the subject
                # that we can use.
                if isinstance(raw_subject, str):
                    safe_subject = raw_subject.encode('us-ascii', 'ignore')
                    self.command_lines.append(safe_subject)
            # Find the first text/plain part of the message.
            part = None
            for part in typed_subpart_iterator(msg, 'text', 'plain'):
                break
            if part is None or part is not msg:
                # Either there was no text/plain part or we ignored some
                # non-text/plain parts.
                print(_('Ignoring non-text/plain MIME parts'), file=results)
            if part is None:
                # There was no text/plain part to be found.
                return
            body = part.get_payload(decode=True)
            # text/plain parts better have string payloads.
            assert body is not None, 'Non-string decoded payload'
            body = body.decode(part.get_content_charset('us-ascii'), errors='replace')
            lines = body.splitlines()
            # Use no more lines than specified
            max_lines = int(config.mailman.email_commands_max_lines)
            self.command_lines.extend(lines[:max_lines])
            self.ignored_lines.extend(lines[max_lines:])
        def __iter__(self):
            """Return each command line, split into space separated arguments."""
            while self.command_lines:
                line = self.command_lines.pop(0)
                self.processed_lines.append(line)
                parts = line.strip().split()
                if len(parts) == 0:
                    continue
                # Ensure that all the parts are unicodes.  Since we only accept
                # ASCII commands and arguments, ignore anything else.
                parts = [(part.lower()
                          if isinstance(part, str)
                          else part.decode('ascii', 'ignore').lower())
                         for part in parts]
                yield parts
    @public
    @implementer(IEmailResults)
    class Results:
        """The email command results."""
        def __init__(self, charset='us-ascii'):
            self._output = StringIO()
            self.charset = charset
            print(_("""\
    The results of your email command are provided below.
    """), file=self._output)
        def write(self, text):
            if isinstance(text, bytes):
                text = text.decode(self.charset, 'ignore')
            self._output.write(text)
        def __str__(self):
            value = self._output.getvalue()
            assert isinstance(value, str), 'Not a string: %r' % value
            return value
    @public
    class CommandRunner(Runner):
        """The email command runner."""
        def _dispose(self, mlist, msg, msgdata):
            message_id = msg.get('message-id', 'n/a')
            # The policy here is similar to the Replybot policy.  If a message has
            # "Precedence: bulk|junk|list" and no "X-Ack: yes" header, we discard
            # the command message.
            precedence = msg.get('precedence', '').lower()
            ack = msg.get('x-ack', '').lower()
            if ack != 'yes' and precedence in ('bulk', 'junk', 'list'):
                log.info('%s Precedence: %s message discarded by: %s',
                         message_id, precedence, mlist.request_address)
                return False
            # Do replybot for commands.
            replybot = config.handlers['replybot']
            replybot.process(mlist, msg, msgdata)
            if mlist.autorespond_requests == ResponseAction.respond_and_discard:
                # Respond and discard.
                log.info('%s -request message replied and discarded', message_id)
                return False
            # Now craft the response and process the command lines.
            charset = msg.get_param('charset')
            if charset is None:
                charset = 'us-ascii'
            results = Results(charset)
            # Include just a few key pieces of information from the original: the
            # sender, date, and message id.
            print(_('- Original message details:'), file=results)
            subject = msg.get('subject', 'n/a')                      # noqa: F841
            date = msg.get('date', 'n/a')                            # noqa: F841
            from_ = msg.get('from', 'n/a')                           # noqa: F841
            print(_('    From: $from_'), file=results)
            print(_('    Subject: $subject'), file=results)
            print(_('    Date: $date'), file=results)
            print(_('    Message-ID: $message_id'), file=results)
            print(_('\n- Results:'), file=results)
            finder = CommandFinder(msg, msgdata, results)
            for parts in finder:
                command = None
                # Try to find a command on this line.  There may be a Re: prefix
                # (possibly internationalized) so try with the first and second
                # words on the line.
                if len(parts) > 0:
                    command_name = parts.pop(0)
                    command = config.commands.get(command_name)
                if command is None and len(parts) > 0:
                    command_name = parts.pop(0)
                    command = config.commands.get(command_name)
                if command is None:
                    print(_('No such command: $command_name'), file=results)
                else:
                    status = command.process(
                        mlist, msg, msgdata, parts, results)
                    assert status in ContinueProcessing, (
                        'Invalid status: %s' % status)
                    if status == ContinueProcessing.no:
                        break
            # All done. If we don't need to send response, return.
            if not finder.send_response:
                return
            # Strip blank lines and send the response.
            lines = [line.strip() for line in finder.command_lines if line]
            if len(lines) > 0:
                print(_('\n- Unprocessed:'), file=results)
                for line in lines:
                    print(line, file=results)
            lines = [line.strip() for line in finder.ignored_lines if line]
            if len(lines) > 0:
                print(_('\n- Ignored:'), file=results)
                for line in lines:
                    print(line, file=results)
            print(_('\n- Done.'), file=results)
            # Send a reply, but do not attach the original message.  This is a
            # compromise because the original message is often helpful in tracking
            # down problems, but it's also a vector for backscatter spam.
            language = getUtility(ILanguageManager)[msgdata['lang']]
            reply = UserNotification(msg.sender, mlist.bounces_address,
                                     _('The results of your email commands'),
                                     lang=language)
            cte = msg.get('content-transfer-encoding')
            if cte is not None:
                reply['Content-Transfer-Encoding'] = cte
            # Find a charset for the response body.  Try the original message's
            # charset first, then ascii, then latin-1 and finally falling back to
            # utf-8.
            reply_body = str(results)
            for charset in (results.charset, 'us-ascii', 'latin-1'):
                with suppress(UnicodeError):
                    reply_body.encode(charset)
                    break
            else:
                charset = 'utf-8'
            reply.set_payload(reply_body, charset=charset)
            reply.send(mlist)
# configmap for mail exim4 service, these three files are directly read from exim config folder
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mailman-exim4-configmap
  namespace: mail
data:
  25_mm3_macros: |
    # Place this file at
    # /etc/exim4/conf.d/main/25_mm3_macros

    domainlist mm3_domains=opengauss.org
    MM3_LMTP_HOST=mailman-core-0.mail-suit-service.mail.svc.cluster.local
    MM3_LMTP_PORT=8024
    # According to the configuration of: https://mailman.readthedocs.io/en/release-3.0/src/mailman/docs/MTA.html
    # We need updating this, for the purpose of delivering emails to the mailman
    MM3_HOME=/opt/mailman/var

    ################################################################
    # The configuration below is boilerplate:
    # you should not need to change it.

    # The path to the list receipt (used as the required file when
    # matching list addresses)
    MM3_LISTCHK=MM3_HOME/lists/${local_part}.${domain}
  
  00_local_macros: |
    DKIM_CANON = relaxed
    DKIM_SELECTOR = default
    DKIM_DOMAIN = opengauss.org
    DKIM_FILE = /etc/exim4/dkim/opengauss.key
    DKIM_PRIVATE_KEY=${if exists{DKIM_FILE}{DKIM_FILE}{0}}
    MAIN_LOG_SELECTOR = +subject +deliver_time +received_sender +return_path_on_delivery +sender_on_delivery +unknown_in_list +smtp_protocol_error +smtp_syntax_error +tls_certificate_verified +tls_peerdn -host_lookup_failed
    MAIN_TLS_ENABLE = yes
    AUTH_SERVER_ALLOW_NOTLS_PASSWORDS = true

  55_mm3_transport: |
    # Place this file at
    # /etc/exim4/conf.d/transport/55_mm3_transport

    mailman3_transport:
      debug_print = "Email for mailman"
      driver = smtp
      protocol = lmtp
      allow_localhost
      hosts = MM3_LMTP_HOST
      port = MM3_LMTP_PORT
      rcpt_include_affixes = true

  455_mm3_router: |
    # Place this file at
    # /etc/exim4/conf.d/router/455_mm3_router

    mailman3_router:
      driver = accept
      domains = +mm3_domains
      require_files = MM3_LISTCHK
      local_part_suffix_optional
      local_part_suffix = -admin : \
         -bounces   : -bounces+* : \
         -confirm   : -confirm+* : \
         -join      : -leave     : \
         -owner     : -request   : \
         -subscribe : -unsubscribe
      transport = mailman3_transport

  01_exim4-config_listmacrosdefs: |
    # Place this file at
    # /etc/exim4/conf.d/main/01_exim4-config_listmacrosdefs
    log_file_path = /var/log/exim4/%s.%M
    exim_path = /usr/sbin/exim4

    # Macro defining the main configuration directory.
    # We do not use absolute paths.
    .ifndef CONFDIR
    CONFDIR = /etc/exim4
    .endif

    # debconf-driven macro definitions get inserted after this line
    UPEX4CmacrosUPEX4C = 1

    # Create domain and host lists for relay control
    # '@' refers to 'the name of the local host'

    # List of domains considered local for exim. Domains not listed here
    # need to be deliverable remotely.
    domainlist local_domains = MAIN_LOCAL_DOMAINS

    # List of recipient domains to relay _to_. Use this list if you're -
    # for example - fallback MX or mail gateway for domains.
    domainlist relay_to_domains = MAIN_RELAY_TO_DOMAINS

    # List of sender networks (IP addresses) to _unconditionally_ relay
    # _for_. If you intend to be SMTP AUTH server, you do not need to enter
    # anything here.
    hostlist relay_from_hosts = MAIN_RELAY_NETS


    # Decide which domain to use to add to all unqualified addresses.
    # If MAIN_PRIMARY_HOSTNAME_AS_QUALIFY_DOMAIN is defined, the primary
    # hostname is used. If not, but MAIN_QUALIFY_DOMAIN is set, the value
    # of MAIN_QUALIFY_DOMAIN is used. If both macros are not defined,
    # the first line of /etc/mailname is used.
    .ifndef MAIN_PRIMARY_HOSTNAME_AS_QUALIFY_DOMAIN
    .ifndef MAIN_QUALIFY_DOMAIN
    qualify_domain = ETC_MAILNAME
    .else
    qualify_domain = MAIN_QUALIFY_DOMAIN
    .endif
    .endif

    # listen on all all interfaces?
    .ifdef MAIN_LOCAL_INTERFACES
    local_interfaces = MAIN_LOCAL_INTERFACES
    .endif

    .ifndef LOCAL_DELIVERY
    # The default transport, set in /etc/exim4/update-exim4.conf.conf,
    # defaulting to mail_spool. See CONFDIR/conf.d/transport/ for possibilities
    LOCAL_DELIVERY=mail_spool
    .endif

    # The gecos field in /etc/passwd holds not only the name. see passwd(5).
    gecos_pattern = ^([^,:]*)
    gecos_name = $1

    .ifndef CHECK_RCPT_LOCAL_LOCALPARTS
    CHECK_RCPT_LOCAL_LOCALPARTS = ^[.] : ^.*[@%!/|`#&?]
    .endif

    .ifndef CHECK_RCPT_REMOTE_LOCALPARTS
    CHECK_RCPT_REMOTE_LOCALPARTS = ^[./|] : ^.*[@%!`#&?] : ^.*/\\.\\./
    .endif

  30_exim4-config_examples: |
    # Place this file at
    # /etc/exim4/conf.d/auth/30_exim4-config_examples

    plain_server:
      driver = plaintext
      public_name = PLAIN
      server_condition = "${if crypteq{$auth3}{${extract{1}{:}{${lookup{$auth2}lsearch{CONFDIR/passwd}{$value}{*:*}}}}}{1}{0}}"
      server_set_id = $auth2
      server_prompts = :
      .ifndef AUTH_SERVER_ALLOW_NOTLS_PASSWORDS
      server_advertise_condition = ${if eq{$tls_in_cipher}{}{}{*}}
      .endif

    login_server:
      driver = plaintext
      public_name = LOGIN
      server_prompts = "Username:: : Password::"
      server_condition = "${if crypteq{$auth2}{${extract{1}{:}{${lookup{$auth1}lsearch{CONFDIR/passwd}{$value}{*:*}}}}}{1}{0}}"
      server_set_id = $auth1
      .ifndef AUTH_SERVER_ALLOW_NOTLS_PASSWORDS
      server_advertise_condition = ${if eq{$tls_in_cipher}{}{}{*}}
      .endif

    cram_md5:
      driver = cram_md5
      public_name = CRAM-MD5
      client_name = ${extract{1}{:}{${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}}}
      client_secret = ${extract{2}{:}{${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}}}

    # this returns the matching line from passwd.client and doubles all ^
    PASSWDLINE=${sg{\
                    ${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}\
    	        }\
    	        {\\N[\\^]\\N}\
    	        {^^}\
    	    }

    plain:
      driver = plaintext
      public_name = PLAIN
    .ifndef AUTH_CLIENT_ALLOW_NOTLS_PASSWORDS
      client_send = "<; ${if !eq{$tls_out_cipher}{}\
                        {^${extract{1}{:}{PASSWDLINE}}\
    		     ^${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}\
    		   }fail}"
    .else
      client_send = "<; ^${extract{1}{:}{PASSWDLINE}}\
    		    ^${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
    .endif

    login:
      driver = plaintext
      public_name = LOGIN
    .ifndef AUTH_CLIENT_ALLOW_NOTLS_PASSWORDS
      # Return empty string if not non-TLS AND looking up $host in passwd-file
      # yields a non-empty string; fail otherwise.
      client_send = "<; ${if and{\
                              {!eq{$tls_out_cipher}{}}\
                              {!eq{PASSWDLINE}{}}\
                             }\
                          {}fail}\
                     ; ${extract{1}{::}{PASSWDLINE}}\
    		 ; ${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
    .else
      # Return empty string if looking up $host in passwd-file yields a
      # non-empty string; fail otherwise.
      client_send = "<; ${if !eq{PASSWDLINE}{}\
                          {}fail}\
                     ; ${extract{1}{::}{PASSWDLINE}}\
    		 ; ${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
    .endif

  update-exim4-conf.conf: |
    dc_eximconfig_configtype='internet'
    dc_other_hostnames='opengauss.org;'
    dc_local_interfaces=''
    dc_readhost=''
    dc_relay_domains=''
    dc_minimaldns='false'
    dc_relay_nets='192.168.0.0/16'
    dc_smarthost=''
    CFILEMODE='644'
    dc_use_split_config='true'
    dc_hide_mailname=''
    dc_mailname_in_oh='true'
    dc_localdelivery='mail_spool'

# configmap for mail web service
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mailman-web-configmap
  namespace: mail
data:
  settings_local.py: |
    import os
    import socket
    import ipaddress

    DEBUG = False

    EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
    #NOTE: this is the MTA host, we need to update it.
    EMAIL_HOST = 'mailman-exim4-service.mail.svc.cluster.local'
    EMAIL_HOST_USER = os.environ.get('EMAIL_HOST_USER')
    EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_HOST_PASSWORD')
    EMAIL_PORT = 25
    
    mailman_ip_address = socket.gethostbyname(os.environ.get('MAILMAN_HOST_IP')).split('.')
    mailman_ip_cidr = "{0}.{1}.0.0/16".format(mailman_ip_address[0], mailman_ip_address[1])
    MAILMAN_ARCHIVER_FROM = [str(ip) for ip in ipaddress.IPv4Network(mailman_ip_cidr)]

    SERVICE_IP = socket.gethostbyname("mailweb.opengauss.org")

    ALLOWED_HOSTS = [
        "localhost",  # Archiving API from Mailman, keep it.
        # Add here all production URLs you may have.
        "192.168.0.164",
        "mailman-core-0.mail-suit-service.mail.svc.cluster.local",
        "mailman-web-0.mail-suit-service.mail.svc.cluster.local",
        "mailman-web-service.mail.svc.cluster.local",
        #NOTE: This is the public ip address of the served host
        "opengauss.org",
        #NOTE: this can be removed if domain name finally get used.
        "159.138.24.25",
        "159.138.9.224",
        "mailweb.opengauss.org",
        "mail.opengauss.org",
        "mailman-web",
        SERVICE_IP,
        os.environ.get('SERVE_FROM_DOMAIN'),
        os.environ.get('DJANGO_ALLOWED_HOSTS'),
    ]

    COMPRESS_CSS_HASHING_METHOD = 'content'
  default.conf: |
    server {
        listen 443 ssl;
  
        root /opt/mailman-web-data;
        index index.html;
        server_name mailweb.opengauss.org;
        ssl on;
        ssl_certificate /etc/nginx/ssl/server.crt;
        ssl_certificate_key  /etc/nginx/ssl/server.key;
        server_tokens off;
        location /static {
          alias /opt/mailman-web-data/static;
        }
        location / {
          uwsgi_pass 127.0.0.1:8080;
          include uwsgi_params;
          uwsgi_read_timeout 300;
        }
        location ^~ /admin {
          deny all;
        }
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mailman-webpage-hack
  namespace: mail
data:
  summary.html: |
    {% extends "postorius/base.html" %}
    {% load i18n %}
    {% load bootstrap_tags %}
    {% load nav_helpers %}

    {% block head_title %}
    {% trans 'Info' %} | {{ list.fqdn_listname }} - {{ block.super }}
    {% endblock %}

    {% block content %}

    {% list_nav 'list_summary' 'Summary' %}

    <p>{{ list.settings.description }}</p>
    {% if list.settings.info %}
    <p><pre style="white-space: pre-wrap; word-break: normal; border: none; background: none;">{{ list.settings.info }}</pre></p>
    {% endif %}
    <p>{% trans 'To contact the list owners, use the following email address:' %} <em>{{ list.settings.owner_address }}</em></p>

    {# Archives #}
    {% if hyperkitty_enabled %}
    {% if not public_archive and not user.is_authenticated %}
    <p>
        {% trans 'You have to login to visit the archives of this list.' %}
    </p>
    {% else %}
    {% url 'hk_list_overview' list.fqdn_listname as hyperkitty_list_url %}
    <p>
        {% blocktrans %}
        To see the prior postings to this list, visit
        <a href="{{ hyperkitty_list_url }}">the archives</a>.
        {% endblocktrans %}
    </p>
    {% endif %}
    {% endif %}

    <hr />

    {# Subscription #}
    {% if user.is_authenticated %}
    {% if user_subscribed %}
    <h2>{% trans 'Subscription / Unsubscription' %}</h2>
    <p>
        {% trans 'You are subscribed to this list with the following address:' %} <em>{{ subscribed_address }}</em>
    </p>
    {% url 'user_list_options' list.list_id as user_list_options_url %}
    <p>
        {% blocktrans %}
        You can manage your subscription on <a href="{{ user_list_options_url }}">your list options page</a>
        {% endblocktrans %}
    </p>
    <p>
    <form method="post" action="{% url 'list_unsubscribe' list.list_id %}">
        {% csrf_token %}
        <input type="hidden" name="email" value="{{ subscribed_address }}" />
        <button type="submit" class="btn btn-danger">{% trans 'Unsubscribe' %}</button>
    </form>
    </p>
    {% elif user_request_pending %}
    <h4>{% trans "You have a subscription request pending. If you don't hear back soon, please contact the list owners." %}</h4>
    {% else %}
    <h2>{% trans 'Subscribe to this list' %}</h2>
    <p>
        {% blocktrans with address=list.settings.join_address %}
        To subscribe you can send an email with 'subscribe' in the subject to
        <a href="mailto:{{ address }}?subject=Subscribe">{{ address }}</a>
        or use the form below:
        {% endblocktrans %}
    </p>
    <form action="{% url 'list_subscribe' list.list_id %}" method="post" class="form-horizontal">
        {% bootstrap_form_horizontal subscribe_form 2 8 'Subscribe' %}
    </form>
    {% endif %}
    {% else %}
    <div>
        <p>
            {% blocktrans %}
            You can also subscribe without creating an account.
            If you wish to do so, please use the form below.
            {% endblocktrans%}
        </p>
        <form action="{% url 'list_anonymous_subscribe' list.list_id %}"
              method="post" class="form-horizontal">
            {% bootstrap_form_horizontal anonymous_subscription_form 2 8 'Subscribe' %}
        </form>
    </div>
    {% endif %}

    {# List metrics #}
    {% if user.is_authenticated %}
    {% if user.is_list_owner or user.is_superuser %}
    <hr />
    <h3>{% trans 'List metrics' %}</h3>
    <dl class="dl-horizontal">
        <dt>{% trans 'Created at' %}</dt><dd>{{ list.settings.created_at }}</dd>
        <dt>{% trans 'Last post at' %}</dt><dd>{{ list.settings.last_post_at }}</dd>
        <dt>{% trans 'Digest last sent at' %}</dt><dd>{{ list.settings.digest_last_sent_at }}</dd>
        <dt>{% trans 'Volume' %}</dt><dd>{{ list.settings.volume }}</dd>
    </dl>
    {% endif %}
    {% endif %}
    {% endblock %}
