---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mailman-core-configmap
  namespace: mail
data:
  #patch base64mime.py for the purpose of encoding fix at: https://bugs.python.org/issue44560
  base64mime.py: |
    # Copyright (C) 2002-2007 Python Software Foundation
    # Author: Ben Gertzfield
    # Contact: email-sig@python.org
    """Base64 content transfer encoding per RFCs 2045-2047.
    This module handles the content transfer encoding method defined in RFC 2045
    to encode arbitrary 8-bit data using the three 8-bit bytes in four 7-bit
    characters encoding known as Base64.
    It is used in the MIME standards for email to attach images, audio, and text
    using some 8-bit character sets to messages.
    This module provides an interface to encode and decode both headers and bodies
    with Base64 encoding.
    RFC 2045 defines a method for including character set information in an
    `encoded-word' in a header.  This method is commonly used for 8-bit real names
    in To:, From:, Cc:, etc. fields, as well as Subject: lines.
    This module does not do the line wrapping or end-of-line character conversion
    necessary for proper internationalized headers; it only does dumb encoding and
    decoding.  To deal with the various line wrapping issues, use the email.header
    module.
    """
    __all__ = [
        'body_decode',
        'body_encode',
        'decode',
        'decodestring',
        'header_encode',
        'header_length',
        ]
    from base64 import b64encode
    from binascii import b2a_base64, a2b_base64
    CRLF = '\r\n'
    NL = '\n'
    EMPTYSTRING = ''
    # See also Charset.py
    MISC_LEN = 7
    # Helpers
    def header_length(bytearray):
        """Return the length of s when it is encoded with base64."""
        groups_of_3, leftover = divmod(len(bytearray), 3)
        # 4 bytes out for each 3 bytes (or nonzero fraction thereof) in.
        n = groups_of_3 * 4
        if leftover:
            n += 4
        return n
    def header_encode(header_bytes, charset='iso-8859-1'):
        """Encode a single header line with Base64 encoding in a given charset.
        charset names the character set to use to encode the header.  It defaults
        to iso-8859-1.  Base64 encoding is defined in RFC 2045.
        """
        if not header_bytes:
            return ""
        if isinstance(header_bytes, str):
            header_bytes = header_bytes.encode(charset)
        encoded = b64encode(header_bytes).decode("ascii")
        if charset == "eucgb2312_cn":
            charset = "gb2312"
        return '=?%s?b?%s?=' % (charset, encoded)
    def body_encode(s, maxlinelen=76, eol=NL):
        r"""Encode a string with base64.
        Each line will be wrapped at, at most, maxlinelen characters (defaults to
        76 characters).
        Each line of encoded text will end with eol, which defaults to "\n".  Set
        this to "\r\n" if you will be using the result of this function directly
        in an email.
        """
        if not s:
            return s
        encvec = []
        max_unencoded = maxlinelen * 3 // 4
        for i in range(0, len(s), max_unencoded):
            # BAW: should encode() inherit b2a_base64()'s dubious behavior in
            # adding a newline to the encoded string?
            enc = b2a_base64(s[i:i + max_unencoded]).decode("ascii")
            if enc.endswith(NL) and eol != NL:
                enc = enc[:-1] + eol
            encvec.append(enc)
        return EMPTYSTRING.join(encvec)
    def decode(string):
        """Decode a raw base64 string, returning a bytes object.
        This function does not parse a full MIME header value encoded with
        base64 (like =?iso-8859-1?b?bmloISBuaWgh?=) -- please use the high
        level email.header class for that functionality.
        """
        if not string:
            return bytes()
        elif isinstance(string, str):
            return a2b_base64(string.encode('raw-unicode-escape'))
        else:
            return a2b_base64(string)
    # For convenience and backwards compatibility w/ standard base64 module
    body_decode = decode
    decodestring = decode
  # patch base64mime.py for the purpose of encoding fix at: https://bugs.python.org/issue44560
  quoprimime.py: |
    # Copyright (C) 2001-2006 Python Software Foundation
    # Author: Ben Gertzfield
    # Contact: email-sig@python.org
    """Quoted-printable content transfer encoding per RFCs 2045-2047.
    This module handles the content transfer encoding method defined in RFC 2045
    to encode US ASCII-like 8-bit data called `quoted-printable'.  It is used to
    safely encode text that is in a character set similar to the 7-bit US ASCII
    character set, but that includes some 8-bit characters that are normally not
    allowed in email bodies or headers.
    Quoted-printable is very space-inefficient for encoding binary files; use the
    email.base64mime module for that instead.
    This module provides an interface to encode and decode both headers and bodies
    with quoted-printable encoding.
    RFC 2045 defines a method for including character set information in an
    `encoded-word' in a header.  This method is commonly used for 8-bit real names
    in To:/From:/Cc: etc. fields, as well as Subject: lines.
    This module does not do the line wrapping or end-of-line character
    conversion necessary for proper internationalized headers; it only
    does dumb encoding and decoding.  To deal with the various line
    wrapping issues, use the email.header module.
    """
    __all__ = [
        'body_decode',
        'body_encode',
        'body_length',
        'decode',
        'decodestring',
        'header_decode',
        'header_encode',
        'header_length',
        'quote',
        'unquote',
        ]
    import re
    from string import ascii_letters, digits, hexdigits
    CRLF = '\r\n'
    NL = '\n'
    EMPTYSTRING = ''
    # Build a mapping of octets to the expansion of that octet.  Since we're only
    # going to have 256 of these things, this isn't terribly inefficient
    # space-wise.  Remember that headers and bodies have different sets of safe
    # characters.  Initialize both maps with the full expansion, and then override
    # the safe bytes with the more compact form.
    _QUOPRI_MAP = ['=%02X' % c for c in range(256)]
    _QUOPRI_HEADER_MAP = _QUOPRI_MAP[:]
    _QUOPRI_BODY_MAP = _QUOPRI_MAP[:]
    # Safe header bytes which need no encoding.
    for c in b'-!*+/' + ascii_letters.encode('ascii') + digits.encode('ascii'):
        _QUOPRI_HEADER_MAP[c] = chr(c)
    # Headers have one other special encoding; spaces become underscores.
    _QUOPRI_HEADER_MAP[ord(' ')] = '_'
    # Safe body bytes which need no encoding.
    for c in (b' !"#$%&\'()*+,-./0123456789:;<>'
              b'?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`'
              b'abcdefghijklmnopqrstuvwxyz{|}~\t'):
        _QUOPRI_BODY_MAP[c] = chr(c)
    # Helpers
    def header_check(octet):
        """Return True if the octet should be escaped with header quopri."""
        return chr(octet) != _QUOPRI_HEADER_MAP[octet]
    def body_check(octet):
        """Return True if the octet should be escaped with body quopri."""
        return chr(octet) != _QUOPRI_BODY_MAP[octet]
    def header_length(bytearray):
        """Return a header quoted-printable encoding length.
        Note that this does not include any RFC 2047 chrome added by
        `header_encode()`.
        :param bytearray: An array of bytes (a.k.a. octets).
        :return: The length in bytes of the byte array when it is encoded with
            quoted-printable for headers.
        """
        return sum(len(_QUOPRI_HEADER_MAP[octet]) for octet in bytearray)
    def body_length(bytearray):
        """Return a body quoted-printable encoding length.
        :param bytearray: An array of bytes (a.k.a. octets).
        :return: The length in bytes of the byte array when it is encoded with
            quoted-printable for bodies.
        """
        return sum(len(_QUOPRI_BODY_MAP[octet]) for octet in bytearray)
    def _max_append(L, s, maxlen, extra=''):
        if not isinstance(s, str):
            s = chr(s)
        if not L:
            L.append(s.lstrip())
        elif len(L[-1]) + len(s) <= maxlen:
            L[-1] += extra + s
        else:
            L.append(s.lstrip())
    def unquote(s):
        """Turn a string in the form =AB to the ASCII character with value 0xab"""
        return chr(int(s[1:3], 16))
    def quote(c):
        return _QUOPRI_MAP[ord(c)]
    def header_encode(header_bytes, charset='iso-8859-1'):
        """Encode a single header line with quoted-printable (like) encoding.
        Defined in RFC 2045, this `Q' encoding is similar to quoted-printable, but
        used specifically for email header fields to allow charsets with mostly 7
        bit characters (and some 8 bit) to remain more or less readable in non-RFC
        2045 aware mail clients.
        charset names the character set to use in the RFC 2046 header.  It
        defaults to iso-8859-1.
        """
        # Return empty headers as an empty string.
        if not header_bytes:
            return ''
        # Iterate over every byte, encoding if necessary.
        encoded = header_bytes.decode('latin1').translate(_QUOPRI_HEADER_MAP)
        # Now add the RFC chrome to each encoded chunk and glue the chunks
        # together.
        if charset == "eucgb2312_cn":
                charset = "gb2312"
        return '=?%s?q?%s?=' % (charset, encoded)
    _QUOPRI_BODY_ENCODE_MAP = _QUOPRI_BODY_MAP[:]
    for c in b'\r\n':
        _QUOPRI_BODY_ENCODE_MAP[c] = chr(c)
    def body_encode(body, maxlinelen=76, eol=NL):
        """Encode with quoted-printable, wrapping at maxlinelen characters.
        Each line of encoded text will end with eol, which defaults to "\\n".  Set
        this to "\\r\\n" if you will be using the result of this function directly
        in an email.
        Each line will be wrapped at, at most, maxlinelen characters before the
        eol string (maxlinelen defaults to 76 characters, the maximum value
        permitted by RFC 2045).  Long lines will have the 'soft line break'
        quoted-printable character "=" appended to them, so the decoded text will
        be identical to the original text.
        The minimum maxlinelen is 4 to have room for a quoted character ("=XX")
        followed by a soft line break.  Smaller values will generate a
        ValueError.
        """
        if maxlinelen < 4:
            raise ValueError("maxlinelen must be at least 4")
        if not body:
            return body
        # quote special characters
        body = body.translate(_QUOPRI_BODY_ENCODE_MAP)
        soft_break = '=' + eol
        # leave space for the '=' at the end of a line
        maxlinelen1 = maxlinelen - 1
        encoded_body = []
        append = encoded_body.append
        for line in body.splitlines():
            # break up the line into pieces no longer than maxlinelen - 1
            start = 0
            laststart = len(line) - 1 - maxlinelen
            while start <= laststart:
                stop = start + maxlinelen1
                # make sure we don't break up an escape sequence
                if line[stop - 2] == '=':
                    append(line[start:stop - 1])
                    start = stop - 2
                elif line[stop - 1] == '=':
                    append(line[start:stop])
                    start = stop - 1
                else:
                    append(line[start:stop] + '=')
                    start = stop
            # handle rest of line, special case if line ends in whitespace
            if line and line[-1] in ' \t':
                room = start - laststart
                if room >= 3:
                    # It's a whitespace character at end-of-line, and we have room
                    # for the three-character quoted encoding.
                    q = quote(line[-1])
                elif room == 2:
                    # There's room for the whitespace character and a soft break.
                    q = line[-1] + soft_break
                else:
                    # There's room only for a soft break.  The quoted whitespace
                    # will be the only content on the subsequent line.
                    q = soft_break + quote(line[-1])
                append(line[start:-1] + q)
            else:
                append(line[start:])
        # add back final newline if present
        if body[-1] in CRLF:
            append('')
        return eol.join(encoded_body)
    # BAW: I'm not sure if the intent was for the signature of this function to be
    # the same as base64MIME.decode() or not...
    def decode(encoded, eol=NL):
        """Decode a quoted-printable string.
        Lines are separated with eol, which defaults to \\n.
        """
        if not encoded:
            return encoded
        # BAW: see comment in encode() above.  Again, we're building up the
        # decoded string with string concatenation, which could be done much more
        # efficiently.
        decoded = ''
        for line in encoded.splitlines():
            line = line.rstrip()
            if not line:
                decoded += eol
                continue
            i = 0
            n = len(line)
            while i < n:
                c = line[i]
                if c != '=':
                    decoded += c
                    i += 1
                # Otherwise, c == "=".  Are we at the end of the line?  If so, add
                # a soft line break.
                elif i+1 == n:
                    i += 1
                    continue
                # Decode if in form =AB
                elif i+2 < n and line[i+1] in hexdigits and line[i+2] in hexdigits:
                    decoded += unquote(line[i:i+3])
                    i += 3
                # Otherwise, not in form =AB, pass literally
                else:
                    decoded += c
                    i += 1
                if i == n:
                    decoded += eol
        # Special case if original string did not end with eol
        if encoded[-1] not in '\r\n' and decoded.endswith(eol):
            decoded = decoded[:-1]
        return decoded
    # For convenience and backwards compatibility w/ standard base64 module
    body_decode = decode
    decodestring = decode
    def _unquote_match(match):
        """Turn a match in the form =AB to the ASCII character with value 0xab"""
        s = match.group(0)
        return unquote(s)
    # Header decoding is done a bit differently
    def header_decode(s):
        """Decode a string encoded with RFC 2045 MIME header `Q' encoding.
        This function does not parse a full MIME header value encoded with
        quoted-printable (like =?iso-8859-1?q?Hello_World?=) -- please use
        the high level email.header class for that functionality.
        """
        s = s.replace('_', ' ')
        return re.sub(r'=[a-fA-F0-9]{2}', _unquote_match, s, flags=re.ASCII)
  command.py: |
    # Copyright (C) 1998-2021 by the Free Software Foundation, Inc.
    #
    # This file is part of GNU Mailman.
    #
    # GNU Mailman is free software: you can redistribute it and/or modify it under
    # the terms of the GNU General Public License as published by the Free
    # Software Foundation, either version 3 of the License, or (at your option)
    # any later version.
    #
    # GNU Mailman is distributed in the hope that it will be useful, but WITHOUT
    # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
    # more details.
    #
    # You should have received a copy of the GNU General Public License along with
    # GNU Mailman.  If not, see <https://www.gnu.org/licenses/>.

    """-request robot command runner."""

    # See the delivery diagram in IncomingRunner.py.  This module handles all
    # email destined for mylist-request, -join, and -leave.  It no longer handles
    # bounce messages (i.e. -admin or -bounces), nor does it handle mail to
    # -owner.

    import base64
    import re
    import logging

    from contextlib import suppress
    from email.errors import HeaderParseError
    from email.header import decode_header, make_header
    from email.iterators import typed_subpart_iterator
    from io import StringIO
    from mailman.config import config
    from mailman.core.i18n import _
    from mailman.core.runner import Runner
    from mailman.email.message import UserNotification
    from mailman.interfaces.autorespond import ResponseAction
    from mailman.interfaces.command import ContinueProcessing, IEmailResults
    from mailman.interfaces.languages import ILanguageManager
    from public import public
    from zope.component import getUtility
    from zope.interface import implementer


    NL = '\n'
    log = logging.getLogger('mailman.vette')
    class CommandFinder:
        """Generate commands from the content of a message."""
        def __init__(self, msg, msgdata, results):
            self.command_lines = []
            self.ignored_lines = []
            self.processed_lines = []
            self.send_response = True
            # Depending on where the message was destined to, add some implicit
            # commands.  For example, if this was sent to the -join or -leave
            # addresses, it's the same as if 'join' or 'leave' commands were sent
            # to the -request address.
            is_address_command = False
            subaddress = msgdata.get('subaddress')
            if subaddress == 'join':
                self.command_lines.append('join')
                self.send_response = False
                is_address_command = True
            elif subaddress == 'leave':
                self.command_lines.append('leave')
                is_address_command = True
                self.send_response = False
            elif subaddress == 'confirm':
                mo = re.match(config.mta.verp_confirm_regexp, msg.get('to', ''))
                if mo:
                    self.command_lines.append('confirm ' + mo.group('cookie'))
                    is_address_command = True
                    self.send_response = False
            # Stop processing if the address already contained a valid command
            if is_address_command:
                return
            # Extract the subject header and do RFC 2047 decoding.
            raw_subject = msg.get('subject', '')
            try:
                subject = str(make_header(decode_header(raw_subject)))
                # Mail commands must be ASCII.
                # NOTE(tommylikehu): remove all none ascii characters via encoding with ignore option.
                self.command_lines.append(subject.encode('us-ascii', 'ignore'))
            except (HeaderParseError, UnicodeError, LookupError):
                # The Subject header was unparseable or not ASCII.  If the raw
                # subject is a unicode object, convert it to ASCII ignoring all
                # bogus characters.  Otherwise, there's nothing in the subject
                # that we can use.
                if isinstance(raw_subject, str):
                    safe_subject = raw_subject.encode('us-ascii', 'ignore')
                    self.command_lines.append(safe_subject)
            # Find the first text/plain part of the message.
            part = None
            for part in typed_subpart_iterator(msg, 'text', 'plain'):
                break
            if part is None or part is not msg:
                # Either there was no text/plain part or we ignored some
                # non-text/plain parts.
                print(_('Ignoring non-text/plain MIME parts'), file=results)
            if part is None:
                # There was no text/plain part to be found.
                return
            body = part.get_payload(decode=True)
            # text/plain parts better have string payloads.
            assert body is not None, 'Non-string decoded payload'
            body = body.decode(part.get_content_charset('us-ascii'), errors='replace')
            lines = body.splitlines()
            # Use no more lines than specified
            max_lines = int(config.mailman.email_commands_max_lines)
            self.command_lines.extend(lines[:max_lines])
            self.ignored_lines.extend(lines[max_lines:])
        def __iter__(self):
            """Return each command line, split into space separated arguments."""
            while self.command_lines:
                line = self.command_lines.pop(0)
                self.processed_lines.append(line)
                parts = line.strip().split()
                if len(parts) == 0:
                    continue
                # Ensure that all the parts are unicodes.  Since we only accept
                # ASCII commands and arguments, ignore anything else.
                parts = [(part.lower()
                          if isinstance(part, str)
                          else part.decode('ascii', 'ignore').lower())
                         for part in parts]
                yield parts
    @public
    @implementer(IEmailResults)
    class Results:
        """The email command results."""
        def __init__(self, charset='us-ascii'):
            self._output = StringIO()
            self.charset = charset
            print(_("""\
    The results of your email command are provided below.
    """), file=self._output)
        def write(self, text):
            if isinstance(text, bytes):
                text = text.decode(self.charset, 'ignore')
            self._output.write(text)
        def __str__(self):
            value = self._output.getvalue()
            assert isinstance(value, str), 'Not a string: %r' % value
            return value
    @public
    class CommandRunner(Runner):
        """The email command runner."""
        def _dispose(self, mlist, msg, msgdata):
            message_id = msg.get('message-id', 'n/a')
            # The policy here is similar to the Replybot policy.  If a message has
            # "Precedence: bulk|junk|list" and no "X-Ack: yes" header, we discard
            # the command message.
            precedence = msg.get('precedence', '').lower()
            ack = msg.get('x-ack', '').lower()
            if ack != 'yes' and precedence in ('bulk', 'junk', 'list'):
                log.info('%s Precedence: %s message discarded by: %s',
                         message_id, precedence, mlist.request_address)
                return False
            # Do replybot for commands.
            replybot = config.handlers['replybot']
            replybot.process(mlist, msg, msgdata)
            if mlist.autorespond_requests == ResponseAction.respond_and_discard:
                # Respond and discard.
                log.info('%s -request message replied and discarded', message_id)
                return False
            # Now craft the response and process the command lines.
            charset = msg.get_param('charset')
            if charset is None:
                charset = 'us-ascii'
            results = Results(charset)
            # Include just a few key pieces of information from the original: the
            # sender, date, and message id.
            print(_('- Original message details:'), file=results)
            subject = msg.get('subject', 'n/a')                      # noqa: F841
            date = msg.get('date', 'n/a')                            # noqa: F841
            from_ = msg.get('from', 'n/a')                           # noqa: F841
            print(_('    From: $from_'), file=results)
            print(_('    Subject: $subject'), file=results)
            print(_('    Date: $date'), file=results)
            print(_('    Message-ID: $message_id'), file=results)
            print(_('\n- Results:'), file=results)
            finder = CommandFinder(msg, msgdata, results)
            for parts in finder:
                command = None
                # Try to find a command on this line.  There may be a Re: prefix
                # (possibly internationalized) so try with the first and second
                # words on the line.
                if len(parts) > 0:
                    command_name = parts.pop(0)
                    command = config.commands.get(command_name)
                if command is None and len(parts) > 0:
                    command_name = parts.pop(0)
                    command = config.commands.get(command_name)
                if command is None:
                    print(_('No such command: $command_name'), file=results)
                else:
                    status = command.process(
                        mlist, msg, msgdata, parts, results)
                    assert status in ContinueProcessing, (
                        'Invalid status: %s' % status)
                    if status == ContinueProcessing.no:
                        break
            # All done. If we don't need to send response, return.
            if not finder.send_response:
                return
            # Strip blank lines and send the response.
            lines = [line.strip() for line in finder.command_lines if line]
            if len(lines) > 0:
                print(_('\n- Unprocessed:'), file=results)
                for line in lines:
                    print(line, file=results)
            lines = [line.strip() for line in finder.ignored_lines if line]
            if len(lines) > 0:
                print(_('\n- Ignored:'), file=results)
                for line in lines:
                    print(line, file=results)
            print(_('\n- Done.'), file=results)
            # Send a reply, but do not attach the original message.  This is a
            # compromise because the original message is often helpful in tracking
            # down problems, but it's also a vector for backscatter spam.
            language = getUtility(ILanguageManager)[msgdata['lang']]
            reply = UserNotification(msg.sender, mlist.bounces_address,
                                     _('The results of your email commands'),
                                     lang=language)
            cte = msg.get('content-transfer-encoding')
            if cte is not None:
                reply['Content-Transfer-Encoding'] = cte
            # Find a charset for the response body.  Try the original message's
            # charset first, then ascii, then latin-1 and finally falling back to
            # utf-8.
            reply_body = str(results)
            for charset in (results.charset, 'us-ascii', 'latin-1'):
                with suppress(UnicodeError):
                    reply_body.encode(charset)
                    break
            else:
                charset = 'utf-8'
            reply.set_payload(reply_body, charset=charset)
            reply.send(mlist)
# configmap for mail exim4 service, these three files are directly read from exim config folder
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mailman-exim4-configmap
  namespace: mail
data:
  25_mm3_macros: |
    # Place this file at
    # /etc/exim4/conf.d/main/25_mm3_macros

    domainlist mm3_domains=opengauss.org
    MM3_LMTP_HOST=mailman-core-0.mail-suit-service.mail.svc.cluster.local
    MM3_LMTP_PORT=8024
    # According to the configuration of: https://mailman.readthedocs.io/en/release-3.0/src/mailman/docs/MTA.html
    # We need updating this, for the purpose of delivering emails to the mailman
    MM3_HOME=/opt/mailman/var

    ################################################################
    # The configuration below is boilerplate:
    # you should not need to change it.

    # The path to the list receipt (used as the required file when
    # matching list addresses)
    MM3_LISTCHK=MM3_HOME/lists/${local_part}.${domain}
  
  00_local_macros: |
    CHECK_RCPT_SPF = true
    DKIM_CANON = relaxed
    DKIM_SELECTOR = default
    DKIM_DOMAIN = opengauss.org
    DKIM_FILE = /etc/exim4/dkim/opengauss.key
    DKIM_PRIVATE_KEY=${if exists{DKIM_FILE}{DKIM_FILE}{0}}
    MAIN_LOG_SELECTOR = +subject +deliver_time +received_sender +return_path_on_delivery +sender_on_delivery +unknown_in_list +smtp_protocol_error +smtp_syntax_error +tls_certificate_verified +tls_peerdn -host_lookup_failed
    MAIN_TLS_ENABLE = yes
    AUTH_SERVER_ALLOW_NOTLS_PASSWORDS = true

  55_mm3_transport: |
    # Place this file at
    # /etc/exim4/conf.d/transport/55_mm3_transport

    mailman3_transport:
      debug_print = "Email for mailman"
      driver = smtp
      protocol = lmtp
      allow_localhost
      hosts = MM3_LMTP_HOST
      port = MM3_LMTP_PORT
      rcpt_include_affixes = true

  455_mm3_router: |
    # Place this file at
    # /etc/exim4/conf.d/router/455_mm3_router

    mailman3_router:
      driver = accept
      domains = +mm3_domains
      require_files = MM3_LISTCHK
      local_part_suffix_optional
      local_part_suffix = -admin : \
         -bounces   : -bounces+* : \
         -confirm   : -confirm+* : \
         -join      : -leave     : \
         -owner     : -request   : \
         -subscribe : -unsubscribe
      transport = mailman3_transport

  01_exim4-config_listmacrosdefs: |
    # Place this file at
    # /etc/exim4/conf.d/main/01_exim4-config_listmacrosdefs
    log_file_path = /var/log/exim4/%s.%M
    exim_path = /usr/sbin/exim4

    # Macro defining the main configuration directory.
    # We do not use absolute paths.
    .ifndef CONFDIR
    CONFDIR = /etc/exim4
    .endif

    # debconf-driven macro definitions get inserted after this line
    UPEX4CmacrosUPEX4C = 1

    # Create domain and host lists for relay control
    # '@' refers to 'the name of the local host'

    # List of domains considered local for exim. Domains not listed here
    # need to be deliverable remotely.
    domainlist local_domains = MAIN_LOCAL_DOMAINS

    # List of recipient domains to relay _to_. Use this list if you're -
    # for example - fallback MX or mail gateway for domains.
    domainlist relay_to_domains = MAIN_RELAY_TO_DOMAINS

    # List of sender networks (IP addresses) to _unconditionally_ relay
    # _for_. If you intend to be SMTP AUTH server, you do not need to enter
    # anything here.
    hostlist relay_from_hosts = MAIN_RELAY_NETS


    # Decide which domain to use to add to all unqualified addresses.
    # If MAIN_PRIMARY_HOSTNAME_AS_QUALIFY_DOMAIN is defined, the primary
    # hostname is used. If not, but MAIN_QUALIFY_DOMAIN is set, the value
    # of MAIN_QUALIFY_DOMAIN is used. If both macros are not defined,
    # the first line of /etc/mailname is used.
    .ifndef MAIN_PRIMARY_HOSTNAME_AS_QUALIFY_DOMAIN
    .ifndef MAIN_QUALIFY_DOMAIN
    qualify_domain = ETC_MAILNAME
    .else
    qualify_domain = MAIN_QUALIFY_DOMAIN
    .endif
    .endif

    # listen on all all interfaces?
    .ifdef MAIN_LOCAL_INTERFACES
    local_interfaces = MAIN_LOCAL_INTERFACES
    .endif

    .ifndef LOCAL_DELIVERY
    # The default transport, set in /etc/exim4/update-exim4.conf.conf,
    # defaulting to mail_spool. See CONFDIR/conf.d/transport/ for possibilities
    LOCAL_DELIVERY=mail_spool
    .endif

    # The gecos field in /etc/passwd holds not only the name. see passwd(5).
    gecos_pattern = ^([^,:]*)
    gecos_name = $1

    .ifndef CHECK_RCPT_LOCAL_LOCALPARTS
    CHECK_RCPT_LOCAL_LOCALPARTS = ^[.] : ^.*[@%!/|`#&?]
    .endif

    .ifndef CHECK_RCPT_REMOTE_LOCALPARTS
    CHECK_RCPT_REMOTE_LOCALPARTS = ^[./|] : ^.*[@%!`#&?] : ^.*/\\.\\./
    .endif

  30_exim4-config_examples: |
    # Place this file at
    # /etc/exim4/conf.d/auth/30_exim4-config_examples

    plain_server:
      driver = plaintext
      public_name = PLAIN
      server_condition = "${if crypteq{$auth3}{${extract{1}{:}{${lookup{$auth2}lsearch{CONFDIR/passwd}{$value}{*:*}}}}}{1}{0}}"
      server_set_id = $auth2
      server_prompts = :
      .ifndef AUTH_SERVER_ALLOW_NOTLS_PASSWORDS
      server_advertise_condition = ${if eq{$tls_in_cipher}{}{}{*}}
      .endif

    login_server:
      driver = plaintext
      public_name = LOGIN
      server_prompts = "Username:: : Password::"
      server_condition = "${if crypteq{$auth2}{${extract{1}{:}{${lookup{$auth1}lsearch{CONFDIR/passwd}{$value}{*:*}}}}}{1}{0}}"
      server_set_id = $auth1
      .ifndef AUTH_SERVER_ALLOW_NOTLS_PASSWORDS
      server_advertise_condition = ${if eq{$tls_in_cipher}{}{}{*}}
      .endif

    cram_md5:
      driver = cram_md5
      public_name = CRAM-MD5
      client_name = ${extract{1}{:}{${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}}}
      client_secret = ${extract{2}{:}{${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}}}

    # this returns the matching line from passwd.client and doubles all ^
    PASSWDLINE=${sg{\
                    ${lookup{$host}nwildlsearch{CONFDIR/passwd.client}{$value}fail}\
    	        }\
    	        {\\N[\\^]\\N}\
    	        {^^}\
    	    }

    plain:
      driver = plaintext
      public_name = PLAIN
    .ifndef AUTH_CLIENT_ALLOW_NOTLS_PASSWORDS
      client_send = "<; ${if !eq{$tls_out_cipher}{}\
                        {^${extract{1}{:}{PASSWDLINE}}\
    		     ^${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}\
    		   }fail}"
    .else
      client_send = "<; ^${extract{1}{:}{PASSWDLINE}}\
    		    ^${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
    .endif

    login:
      driver = plaintext
      public_name = LOGIN
    .ifndef AUTH_CLIENT_ALLOW_NOTLS_PASSWORDS
      # Return empty string if not non-TLS AND looking up $host in passwd-file
      # yields a non-empty string; fail otherwise.
      client_send = "<; ${if and{\
                              {!eq{$tls_out_cipher}{}}\
                              {!eq{PASSWDLINE}{}}\
                             }\
                          {}fail}\
                     ; ${extract{1}{::}{PASSWDLINE}}\
    		 ; ${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
    .else
      # Return empty string if looking up $host in passwd-file yields a
      # non-empty string; fail otherwise.
      client_send = "<; ${if !eq{PASSWDLINE}{}\
                          {}fail}\
                     ; ${extract{1}{::}{PASSWDLINE}}\
    		 ; ${sg{PASSWDLINE}{\\N([^:]+:)(.*)\\N}{\\$2}}"
    .endif

  update-exim4-conf.conf: |
    dc_eximconfig_configtype='internet'
    dc_other_hostnames='opengauss.org;'
    dc_local_interfaces=''
    dc_readhost=''
    dc_relay_domains=''
    dc_minimaldns='false'
    dc_relay_nets='192.168.0.0/16'
    dc_smarthost=''
    CFILEMODE='644'
    dc_use_split_config='true'
    dc_hide_mailname=''
    dc_mailname_in_oh='true'
    dc_localdelivery='mail_spool'

# configmap for mail web service
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mailman-web-configmap
  namespace: mail
data:
  base.html: |
    {% load i18n %}
    {% load staticfiles %}
    {% load gravatar %}
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>{% block head_title %}{{ site_name }}{% endblock %}</title>
        <link rel="shortcut icon" href="{% static 'postorius/img/favicon.ico' %}">
        <link rel="stylesheet" href="{% static 'postorius/libs/bootstrap/css/bootstrap.min.css' %}">
        <link rel="stylesheet" href="{% static 'django-mailman3/css/main.css' %}">
        <link rel="stylesheet" href="{% static 'postorius/css/style.css' %}">
        {% block additionalcss %}{% endblock %}
        <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
          <script src="{% static 'postorius/libs/html5shiv/html5shiv.min.js' %}"></script>
          <script src="{% static 'postorius/libs/respond/respond.min.js' %}"></script>
        <![endif]-->
    </head>
    <body>
    
        <nav class="navbar navbar-default">
                <div class="container">
                        <div class="navbar-header">
                                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#header-nav" aria-expanded="false">
                                        <span class="sr-only">Toggle navigation</span>
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                </button>
                                <a class="navbar-brand" href="{% url 'list_index' %}"><span><img src="{% static 'postorius/img/mailman_logo_small_trans.png' %}" alt="{% trans 'Mailman logo' %}"/> Postorius</span></a>
                        </div>
                        <div class="collapse navbar-collapse" id="header-nav">
                                <ul class="nav navbar-nav">
                                        <li><a href="{% url 'list_index' %}">
                                                <span class="glyphicon glyphicon-envelope"></span>
                                                {% trans 'Lists' %}
                                        </a></li>
                                        {% if user.is_superuser %}
                                                <li><a href="{% url 'domain_index' %}">
                                                        <span class="glyphicon glyphicon-globe"></span>
                                                        {% trans 'Domains' %}
                                                </a></li>
                                                <li>
                                                        <a href="{% url 'system_information' %}">
                                                                <span class="glyphicon glyphicon-list-alt"></span>
                                                                {% trans 'System Information' %}
                                                        </a>
                                                </li>
                                        {% endif %}
                                        {% if 'hyperkitty' in INSTALLED_APPS %}
                                                <li><a href="{% url 'hk_root' %}">
                                                        <span class="glyphicon glyphicon-comment"></span>
                                                        {% trans 'Archives' %}
                                                </a></li>
                                        {% endif %}
                                </ul>
                                <ul class="nav navbar-nav navbar-right">
                                        {% if user.is_authenticated %}
                                                <li class="dropdown">
                                                        <a href="#" class="dropdown-toggle" data-toggle="dropdown"
                                                           role="button" aria-haspopup="true" aria-expanded="false">
                                                                {% gravatar user.email 20 %}
                                                                {{ user.username|truncatechars:"35" }}
                                                                <span class="caret"></span>
                                                        </a>
                                                        <ul class="dropdown-menu">
                                                                <li><a href="{% url 'mm_user_profile' %}">
                                                                        <span class="glyphicon glyphicon-user"></span>
                                                                        {% trans 'Account' %}
                                                                </a></li>
                                                                <li><a href="{% url 'ps_user_profile' %}">
                                                                        <span class="glyphicon glyphicon-cog"></span>
                                                                        {% trans 'Mailman settings' %}
                                                                </a></li>
                                                                {% if 'hyperkitty' in INSTALLED_APPS %}
                                                                <li><a href="{% url 'hk_user_profile' %}">
                                                                <span class="glyphicon glyphicon-comment"></span>
                                                                        {% trans 'Posting activity' %}
                                                                </a></li>
                                                                {% endif %}
                                                                <li role="separator" class="divider"></li>
                                                                <li><a href="{% url LOGOUT_URL %}?next={% url 'list_index' %}">
                                                                        <span class="glyphicon glyphicon-log-out"></span>
                                                                        {% trans 'Logout' %}
                                                                </a></li>
                                                        </ul>
                                                </li>
                                        {% else %}
                                                <li><a href="{% url LOGIN_URL %}?next={{ next|default:request.path|urlencode }}">
                                                        <span class="glyphicon glyphicon-log-in"></span>
                                                        {% trans 'Login' %}
                                                </a></li>
                                                <!-- <li><a href="{% url 'account_signup' %}?next={{next|default:request.path|urlencode}}">
                                                        <span class="glyphicon glyphicon-plus-sign"></span>
                                                        {% trans 'Sign Up' %}
                                                </a></li> -->
                                        {% endif %}
                                </ul>
                        </div>
                </div>
        </nav>
    
        <div class="container" role="main">
                {% for message in messages %}
                        <div class="alert alert-{{ message.tags }}">{{ message }}</div>
                {% endfor %}
                {% block content %}{% endblock content %}
        </div>
    
        <footer class="footer">
                <div class="container">
                        <p class="text-center">
                                <a href="https://postorius.readthedocs.org">{% trans 'Postorius Documentation' %}</a>
                                &bull;
                                <a href="http://list.org">GNU Mailman</a>
                                &bull;
                                {% trans 'Postorius Version' %} {{ POSTORIUS_VERSION }}
                        </p>
                </div>
        </footer>
    
        <script src="{% static 'postorius/libs/jquery/jquery-1.11.3.min.js' %}"></script>
        <script src="{% static 'postorius/libs/bootstrap/js/bootstrap.min.js' %}"></script>
        <script src="{% static 'django-mailman3/js/main.js' %}"></script>
        <script src="{% static 'postorius/js/script.js' %}"></script>
        {% block additionaljs %}{% endblock %}
    </body>
    </html>
  base2.html: |  
    {% load i18n %}
    {% load compress %}
    {% load static %}
    {% load gravatar %}
    <!DOCTYPE HTML>
    <html>
        <head>
                <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                <meta name="ROBOTS" content="INDEX, FOLLOW" />
                <title>{% block head_title %}{{ site_name }}{% endblock %}</title>
                <meta name="author" content="" />
                <meta name="dc.language" content="en" />
                <link rel="shortcut icon" href="{% static 'hyperkitty/img/favicon.ico' %}" />
                <link rel="stylesheet" href="{% static 'hyperkitty/libs/jquery/smoothness/jquery-ui-1.10.3.custom.min.css' %}" type="text/css" media="all" />
                <link rel="stylesheet" href="{% static 'hyperkitty/libs/fonts/font-awesome/css/font-awesome.min.css' %}" type="text/css" media="all" />
                {% compress css %}
                <link rel="stylesheet" href="{% static 'hyperkitty/libs/fonts/icomoon/icomoon.css' %}" type="text/css" media="all" />
                <link rel="stylesheet" href="{% static 'hyperkitty/libs/fonts/droid/droid.css' %}" type="text/css" media="all" />
                <link rel="stylesheet" href="{% static 'django-mailman3/css/main.css' %}" />
                <link rel="stylesheet" type="text/x-scss" media="all" href="{% static 'hyperkitty/sass/hyperkitty.scss' %}" />
                {% endcompress %}
                {% block additional_stylesheets %} {% endblock %}
                {% include 'hyperkitty/headers.html' %}
        </head>
    
        <body>
    
        {% include 'hyperkitty/top.html' %}
    
        <nav class="navbar navbar-fixed-top navbar-default">
                <div class="container">
                        <div class="navbar-header col-md"> <!--part of navbar that's always present-->
                                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                </button>
                                {% include 'hyperkitty/navbar-brand.html' %}
                        </div> <!-- /navbar-header -->
    
                        <div class="navbar-collapse collapse"> <!--part of navbar that's collapsed on small screens-->
                                <!-- show dropdown for smaller viewports b/c login name/email may be too long -->
                                <!-- only show this extra button/dropdown if we're in small screen sizes -->
                                <div class="nav navbar-nav navbar-right auth dropdown navbar-form hidden-tn hidden-xs hidden-md hidden-lg">
                                        <button type="button" class="btn dropdown-toggle" id="loginDropdownMenu" data-toggle="dropdown">
                                                {% if user.is_authenticated %}
                                                        {% gravatar user.email 20 %}
                                                {% else %}
                                                        <span class="fa fa-bars"></span>
                                                {% endif %}
                                        </button>
                                        <ul class="dropdown-menu" role="menu" aria-labelledby="loginDropdownMenu">
                                                {% if user.is_authenticated %}
                                                        <li role="presentation"><a role="menuitem" tabindex="-1" href="{% url 'mm_user_profile' %}">
                                                                <span class="fa fa-user"></span>
                                                                {% trans 'Account' %}
                                                        </a></li>
                                                        {% if 'postorius' in INSTALLED_APPS %}
                                                        <li role="presentation"><a role="menuitem" tabindex="-1" href="{% url 'ps_user_profile' %}">
                                                                <span class="fa fa-cog"></span>
                                                                {% trans 'Mailman settings' %}
                                                        </a></li>
                                                        {% endif %}
                                                        <li role="presentation"><a role="menuitem" tabindex="-1" href="{% url 'hk_user_profile' %}">
                                                                <span class="fa fa-comments"></span>
                                                                {% trans 'Posting activity' %}
                                                        </a></li>
                                                        <li role="separator" class="divider"></li>
                                                        <li role="presentation"><a role="menuitem" tabindex="-1" href="{% url LOGOUT_URL %}?next={% url 'hk_root' %}">
                                                                <span class="fa fa-sign-out"></span>
                                                                {% trans "Logout" %}
                                                        </a></li>
                                                {% else %}
                                                        <li role="presentation"><a role="menuitem" tabindex="-1" href="{% url LOGIN_URL %}?next={{next|default:request.path|urlencode}}">
                                                                <span class="fa fa-sign-in"></span>
                                                                {% trans "Sign In" %}
                                                        </a></li>
                                                        <!-- <li role="presentation"><a role="menuitem" tabindex="-1" href="{% url 'account_signup' %}?next={{next|default:request.path|urlencode}}">
                                                                <span class="fa fa-user-plus"></span>
                                                                {% trans "Sign Up" %}
                                                        </a></li> -->
                                                {% endif %}
                                        </ul>
                                </div>
                                <!-- larger viewports -->
                                <ul class="nav navbar-nav navbar-right hidden-sm auth">
                                        {% if user.is_authenticated %}
                                                <li class="dropdown">
                                                        <a href="#" class="dropdown-toggle" data-toggle="dropdown"
                                                           role="button" aria-haspopup="true" aria-expanded="false">
                                                                {% gravatar user.email 20 %}
                                                                {{ user.username|truncatechars:"35" }}
                                                                <span class="caret"></span>
                                                        </a>
                                                        <ul class="dropdown-menu">
                                                                <li><a href="{% url 'mm_user_profile' %}">
                                                                        <span class="fa fa-user"></span>
                                                                        {% trans 'Account' %}
                                                                </a></li>
                                                                {% if 'postorius' in INSTALLED_APPS %}
                                                                <li><a href="{% url 'ps_user_profile' %}">
                                                                        <span class="fa fa-cog"></span>
                                                                        {% trans 'Mailman settings' %}
                                                                </a></li>
                                                                {% endif %}
                                                                <li><a href="{% url 'hk_user_profile' %}">
                                                                        <span class="fa fa-comments"></span>
                                                                        {% trans 'Posting activity' %}
                                                                </a></li>
                                                                <li role="separator" class="divider"></li>
                                                                <li><a href="{% url LOGOUT_URL %}?next={% url 'hk_root' %}">
                                                                        <span class="fa fa-sign-out"></span>
                                                                        {% trans "Logout" %}
                                                                </a></li>
                                                        </ul>
                                                </li>
                                        {% else %}
                                                <li><a href="{% url LOGIN_URL %}?next={{next|default:request.path|urlencode}}">
                                                        <span class="fa fa-sign-in"></span>
                                                        {% trans "Sign In" %}
                                                </a></li>
                                                <!-- <li><a href="{% url 'account_signup' %}?next={{next|default:request.path|urlencode}}">
                                                        <span class="fa fa-user-plus"></span>
                                                        {% trans "Sign Up" %}
                                                </a></li> -->
                                        {% endif %}
                                </ul>
    
                                {% if 'postorius' in INSTALLED_APPS %}
                                <ul class="nav navbar-nav navbar-right"><li>
                                        {% if mlist %}
                                        <a href="{% url 'list_summary' mlist.list_id %}">
                                                <span class="fa fa-cog"></span>
                                                {% trans 'Manage this list' %}
                                        </a>
                                        {% else %}
                                        <a href="{% url 'list_index' %}">
                                                <span class="fa fa-cog"></span>
                                                {% trans 'Manage lists' %}
                                        </a>
                                        {% endif %}
                                </li></ul>
                                {% endif %}
    
                                <form name="search" method="get" action="{% url 'hk_search' %}" class="navbar-form navbar-right" role="search">
                                        {% if mlist %}<input type="hidden" name="mlist" value="{{ mlist.name }}" />{% endif %}
                                        <div class="form-group">
                                                <div class="input-group">
                                                        <input name="q" type="text" class="form-control"
                                                                   placeholder="Search {% if mlist %}this list{% else %}all lists{% endif %}"
                                                                   {% if query %}value="{{ query }}"{% endif %}
                                                                   />
                                                        <span class="input-group-btn">
                                                                <button class="btn btn-default" type="submit"><span class="fa fa-search"></span></button>
                                                        </span>
                                                </div>
                                        </div>
                                </form>
    
                        </div> <!--/navbar-collapse -->
                </div> <!-- /container for navbar -->
        </nav>
    
        {% if messages %}
        <div class="flashmsgs">
        {% for msg in messages %}
                <div class="flashmsg-wrapper">
                        <!--<div class="alert alert-{{ msg.level_tag }} {{ msg.extra_tags }}">-->
                        <div class="alert {{ msg.tags }}
                                {% if msg.level == DEFAULT_MESSAGE_LEVELS.SUCCESS %}
                                ">
                                {% else %}
                                alert-dismissible">
                                <button type="button" class="close" data-dismiss="alert">&times;</button>
                                {% endif %}
                        {{ msg }}
                        </div>
                </div>
        {% endfor %}
        </div>
        {% endif %}
    
        <div class="container">
    
                {% block content %} {% endblock %}
    
        </div> <!-- /container for content -->
    
        <footer class="footer">
          <div class="container">
                <p class="text-muted">
                        Powered by <a href="http://hyperkitty.readthedocs.org">HyperKitty</a> version {{ HYPERKITTY_VERSION }}.
                </p>
          </div>
        </footer>
    
        <script src="{% static 'hyperkitty/libs/jquery/jquery-1.10.1.min.js' %}"></script>
        <script src="{% static 'hyperkitty/libs/jquery/jquery-ui-1.10.3.custom.min.js' %}"></script>
        {% compress js %}
        <script type="text/javascript" src="{% static 'hyperkitty/libs/bootstrap/javascripts/bootstrap.min.js' %}" />
        <script type="text/javascript" src="{% static 'hyperkitty/libs/jquery.expander.js' %}" />
        <script type="text/javascript" src="{% static 'hyperkitty/libs/d3.v2.min.js' %}" />
        <script type="text/javascript" src="{% static 'hyperkitty/libs/jquery.hotkeys.js' %}" />
        <script type="text/javascript" src="{% static 'django-mailman3/js/main.js' %}" />
        <script type="text/javascript" src="{% static 'hyperkitty/js/hyperkitty-common.js' %}" />
        <script type="text/javascript" src="{% static 'hyperkitty/js/hyperkitty-index.js' %}" />
        <script type="text/javascript" src="{% static 'hyperkitty/js/hyperkitty-overview.js' %}" />
        <script type="text/javascript" src="{% static 'hyperkitty/js/hyperkitty-thread.js' %}" />
        <script type="text/javascript" src="{% static 'hyperkitty/js/hyperkitty-userprofile.js' %}" />
        {% endcompress %}
        {% block additionaljs %} {% endblock %}
    
        {% include 'hyperkitty/bottom.html' %}
    
        </body>
    </html>
  settings_local.py: |
    import os
    import socket
    import ipaddress

    DEBUG = False

    EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
    #NOTE: this is the MTA host, we need to update it.
    EMAIL_HOST = 'mailman-exim4-service.mail.svc.cluster.local'
    EMAIL_HOST_USER = os.environ.get('EMAIL_HOST_USER')
    EMAIL_HOST_PASSWORD = os.environ.get('EMAIL_HOST_PASSWORD')
    EMAIL_PORT = 25
    
    mailman_ip_address = socket.gethostbyname(os.environ.get('MAILMAN_HOST_IP')).split('.')
    mailman_ip_cidr = "{0}.{1}.0.0/16".format(mailman_ip_address[0], mailman_ip_address[1])
    MAILMAN_ARCHIVER_FROM = [str(ip) for ip in ipaddress.IPv4Network(mailman_ip_cidr)]

    SERVICE_IP = socket.gethostbyname("mailweb.opengauss.org")

    ALLOWED_HOSTS = [
        "localhost",  # Archiving API from Mailman, keep it.
        # Add here all production URLs you may have.
        "192.168.0.164",
        "mailman-core-0.mail-suit-service.mail.svc.cluster.local",
        "mailman-web-0.mail-suit-service.mail.svc.cluster.local",
        "mailman-web-service.mail.svc.cluster.local",
        #NOTE: This is the public ip address of the served host
        "opengauss.org",
        #NOTE: this can be removed if domain name finally get used.
        "159.138.24.25",
        "159.138.9.224",
        "mailweb.opengauss.org",
        "mail.opengauss.org",
        "mailman-web",
        SERVICE_IP,
        os.environ.get('SERVE_FROM_DOMAIN'),
        os.environ.get('DJANGO_ALLOWED_HOSTS'),
    ]

    COMPRESS_CSS_HASHING_METHOD = 'content'
    INSTALLED_APPS = [
      'hyperkitty',
      'postorius',
      'django_mailman3',
      'django.contrib.admin',
      'django.contrib.auth',
      'django.contrib.contenttypes',
      'django.contrib.sessions',
      'django.contrib.sites',
      'django.contrib.messages',
      'django.contrib.staticfiles',
      'rest_framework',
      'django_gravatar',
      'compressor',
      'haystack',
      'django_extensions',
      'django_q',
      'allauth',
      'allauth.account',
      'allauth.socialaccount',
    ]
  default.conf: |
    server {
        listen 443 ssl;
  
        root /opt/mailman-web-data;
        index index.html;
        server_name mailweb.opengauss.org;
        ssl_certificate /etc/nginx/ssl/server.crt;
        ssl_certificate_key  /etc/nginx/ssl/server.key;
        server_tokens off;
        location /static {
          alias /opt/mailman-web-data/static;
        }
        location / {
          uwsgi_pass 127.0.0.1:8080;
          include uwsgi_params;
          uwsgi_read_timeout 300;
        }
        location ^~ /admin {
          deny all;
        }
        location /accounts/signup {
        rewrite ^/accounts/signup(.*)$ /postorius/lists/;
        }
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mailman-webpage-hack
  namespace: mail
data:
  summary.html: |
    {% extends "postorius/base.html" %}
    {% load i18n %}
    {% load bootstrap_tags %}
    {% load nav_helpers %}

    {% block head_title %}
    {% trans 'Info' %} | {{ list.fqdn_listname }} - {{ block.super }}
    {% endblock %}

    {% block content %}

    {% list_nav 'list_summary' 'Summary' %}

    <p>{{ list.settings.description }}</p>
    {% if list.settings.info %}
    <p><pre style="white-space: pre-wrap; word-break: normal; border: none; background: none;">{{ list.settings.info }}</pre></p>
    {% endif %}
    <p>{% trans 'To contact the list owners, use the following email address:' %} <em>{{ list.settings.owner_address }}</em></p>

    {# Archives #}
    {% if hyperkitty_enabled %}
    {% if not public_archive and not user.is_authenticated %}
    <p>
        {% trans 'You have to login to visit the archives of this list.' %}
    </p>
    {% else %}
    {% url 'hk_list_overview' list.fqdn_listname as hyperkitty_list_url %}
    <p>
        {% blocktrans %}
        To see the prior postings to this list, visit
        <a href="{{ hyperkitty_list_url }}">the archives</a>.
        {% endblocktrans %}
    </p>
    {% endif %}
    {% endif %}

    <hr />

    {# Subscription #}
    {% if user.is_authenticated %}
    {% if user_subscribed %}
    <h2>{% trans 'Subscription / Unsubscription' %}</h2>
    <p>
        {% trans 'You are subscribed to this list with the following address:' %} <em>{{ subscribed_address }}</em>
    </p>
    {% url 'user_list_options' list.list_id as user_list_options_url %}
    <p>
        {% blocktrans %}
        You can manage your subscription on <a href="{{ user_list_options_url }}">your list options page</a>
        {% endblocktrans %}
    </p>
    <p>
    <form method="post" action="{% url 'list_unsubscribe' list.list_id %}">
        {% csrf_token %}
        <input type="hidden" name="email" value="{{ subscribed_address }}" />
        <button type="submit" class="btn btn-danger">{% trans 'Unsubscribe' %}</button>
    </form>
    </p>
    {% elif user_request_pending %}
    <h4>{% trans "You have a subscription request pending. If you don't hear back soon, please contact the list owners." %}</h4>
    {% else %}
    <h2>{% trans 'Subscribe to this list' %}</h2>
    <p>
        {% blocktrans with address=list.settings.join_address %}
        To subscribe you can send an email with 'subscribe' in the subject to
        <a href="mailto:{{ address }}?subject=Subscribe">{{ address }}</a>
        or use the form below:
        {% endblocktrans %}
    </p>
    <form action="{% url 'list_subscribe' list.list_id %}" method="post" class="form-horizontal">
        {% bootstrap_form_horizontal subscribe_form 2 8 'Subscribe' %}
    </form>
    {% endif %}
    {% else %}
    <div>
        <p>
            {% blocktrans %}
            You can also subscribe without creating an account.
            If you wish to do so, please use the form below.
            {% endblocktrans%}
        </p>
        <form action="{% url 'list_anonymous_subscribe' list.list_id %}"
              method="post" class="form-horizontal">
            {% bootstrap_form_horizontal anonymous_subscription_form 2 8 'Subscribe' %}
        </form>
    </div>
    {% endif %}

    {# List metrics #}
    {% if user.is_authenticated %}
    {% if user.is_list_owner or user.is_superuser %}
    <hr />
    <h3>{% trans 'List metrics' %}</h3>
    <dl class="dl-horizontal">
        <dt>{% trans 'Created at' %}</dt><dd>{{ list.settings.created_at }}</dd>
        <dt>{% trans 'Last post at' %}</dt><dd>{{ list.settings.last_post_at }}</dd>
        <dt>{% trans 'Digest last sent at' %}</dt><dd>{{ list.settings.digest_last_sent_at }}</dd>
        <dt>{% trans 'Volume' %}</dt><dd>{{ list.settings.volume }}</dd>
    </dl>
    {% endif %}
    {% endif %}
    {% endblock %}
